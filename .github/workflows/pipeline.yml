name: Deploy Workflow
on: deployment
jobs:
  deploy-ENVIRONMENT_NAME:
    name: Deploy to ENVIRONMENT_NAME environment
    if: ${{ github.event.deployment.environment }} == ENVIRONMENT_NAME
    concurrency: ENVIRONMENT_NAME
    permissions:
      deployments: write
      contents: read
    runs-on: self-hosted
    container: alpine/git:latest
    steps:
      - uses: actions/checkout@v4
      - name: Install kubectl
        run: |
          apk update
          apk add kubectl
      - name: Update deployment status (pending)
        if: success()
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          state: 'pending'
          deployment-id: ${{ github.event.deployment.id }}
      - name: Deploy my app
        env:
          KUBE_NAMESPACE: ${{ github.event.deployment.payload.variables.KUBE_NAMESPACE }}
          DEPLOY_FOLDER: environments/${{ github.event.deployment.environment }} # Assumendo che il nome del tuo environment sia 'dev'
        run: |
          # 1. Configurazione dell'Ambiente Minikube
          # Questo comando configura KUBECONFIG e le credenziali corrette
          # all'interno del Self-Hosted Runner.
          eval $(minikube -p minikube shell-env)
          
          # 2. Creazione del Namespace
          kubectl create namespace "${KUBE_NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
          
          # 3. Deployment dei file YAML
          echo "Starting deployment of files in ${DEPLOY_FOLDER}..."
          kubectl apply -k "${DEPLOY_FOLDER}"
          
          echo "Deployment completed."
      - name: Update deployment status (failure)
        if: failure()
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          state: 'failure'
          deployment-id: ${{ github.event.deployment.id }}
